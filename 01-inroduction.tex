\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. From an unpopular language used to add dynamic effects to web pages to one widely used with a strong and growing community. It emerged from a browser-only language to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. The new use cases come along with new requirements demanding for more computational resources that can no longer be provided by a single threaded environment without negative effecting the user experience. This becomes even more sever with the spreading use of mobile devices in the world wide web. The cpus of nowadays mobil devices have  --- compared to desktop computers --- a lower clock rate that is recompensed by the higher number of cpu-cores. However, this requires that application make use of the available computation resources. 

The W3C responded to this new requirements with the web worker draft in 2009 providing the infrastructure for creating multi-threaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker api that allows to run scripts in background-threads. Each thread has its own memory area since the JavaScript memory model is not defined for concurrent access. This requires that cloned values are passed between threads using messaging. However, the messaging based programing model does not fit well into existing applications and the gap between the models needs to be bridged by the programmer --- adding non inherent complexity to the program. The web worker standard further requires that code running in background-threads is located in designated files. This separates coherent logic --- making the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main-thread and another for the code running in web workers. 

Unfortunately, implementing multi-threaded applications targeting different environments in JavaScript is non trivial since no uniform standard for creating background-threads exists. The web worker standard, defined by the W3C consortium, is only implemented in browsers. NodeJS allows to spawn sub process using the child-process api~\cite{childProcess}. JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS} that enables multi-threaded JavaScript --- including shared memory and all problems shared state brings with it. Therefore, an application needs to explicitly be adopted to the standard provided by its supported environments.

I believe that the platform dependent standards together with the inherent complexity caused by the programing model gap are the main reasons for the low spread of multi-threaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform independent, type safe api and runtime system for creating multi-threaded applications in JavaScript. The api abstracts the messaging based programing model used by some of the underlining standards, allowing a seamless integration into existing code. The runtime system consists of two parts: A low level api allowing to run single functions on a background-thread and a reactive api inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive api is mainly designed with simplicity in mind covering the aspects of work partitioning and result joining while providing a well-known and familiar api that allows an easy transformation of existing code. The low level api is designated for the cases where more flexibility is needed or when the reactive programing model does not fit well to the problem to solve. 

Some differences between the programing model cannot be hidden just by the runtime system. The gap is further reduced by the presented transpiler that rewrites the code to reduce the programing model gap to a minimum. The transpiler adds debugging support, allows function to import functionalities from libraries, calling other functions or accessing read only variables from the outer closure. However, the use of the transpiler remains optional. 


The first secton of this paper describes the related work and compares it to the presented solution. The following \cref{sec:programing-model} describes the programing model of parallel tasks and is followed by the \cref{sec:runtime-system} that explains the functionality of the runtime system. The \cref{sec:transpiler} explains which programing model differences can be hidden when using the transpiler. The \cref{sec:evaluation} compares the presented runtime system with the existing work and is followed by the conclusion. 