\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. From an unpopular language used to add dynamic effects to web pages to one widely used with a strong and growing community. It emerged from a browser-only language to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. The new use cases come along with new requirements demanding for more computational resources that can no longer be provided by a single threaded environment without negative effecting the user experience. The W3C responded to this new requirements with the Web Worker api draft in 2009 providing the infrastructure for creating multithreaded applications~\cite{w3cWebWorker}. However, the web worker api requires that the code for web workers is located in a separate file resulting in separating code that belongs together and an increased complexity to the build procedure. Furthermore, the Communication between the main thread and web workers --- and between web workers --- is only messaging based. The messaging based programing model often does not fit well into the existing application design. 

Besides that the programing model from Web Workers differs from the normal JavaScript programing model it is also not universal across platforms. The Web Worker draft is specified as Web api standard that is only implemented by browsers and is therefore not available in non-browser environments. NodeJS provides the child-process api that allows to spawn new child processes allowing to simulate a multithreaded application. However, this requires that messaging is used since the processes have no shared memory as it is the case for Web Workers. I believe that platform dependence together with the inherent complexity of the low level apis are the main reasons for the slow adaption and low exploitation of the available computation resources.\todo{Mention negative impact on usability?}

This paper presents parallel.es, a platform independent, type safe api and a runtime system for performing parallel computations using JavaScript. The main goals of the proposed api are a seamless integration into the existing code base and simplicity. The runtime system consists of two parts. At one hand the system provides a low level api allowing to run single functions on a background thread. At the other hand a reactive api is provided that is based upon the low level api and is inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive api is mainly designed with simplicity in mind covering the aspects of work partitioning and result joining while providing a well-known and familiar api. The low level api is designated for those requiring more flexibility or where the reactive programing model does not fit well to the problem to solve. 
		
In addition to the runtime system a transpiler that automatically extracts functions executed in background threads into a designated file and hides limitations inherent from the programing model gap by rewriting the code. This includes features like debugging, access to variables from the outer scope or importing functionalities from other files --- e.g. using functions from libraries.

The \cref{sec:related-work} describes and compares existing work in the same area with the proposed solution. The \cref{sec:programing-model} describes the programing model of parallel tasks, followed by \cref{sec:runtime-system} that explains the design and implementation of the runtime system and \cref{sec:transpiler} describing which limitations of the runtime system can be hidden by using the transpiler. The \cref{sec:evaluation} compares the presented runtime system with the existing work and is followed by the conclusion. 