\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. From an unpopular language used to add dynamic effects to web pages to one widely used with a strong and growing community. It emerged from a browser-only language to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. The new use cases come along with new requirements demanding for more computational resources that can no longer be provided by a single threaded environment without negative affecting the user experience. This becomes, even more, severe with the spreading use of mobile devices in the world-wide-web. The CPUs of nowadays mobile devices have  --- compared to desktop computers --- a lower clock rate that is recompensed by the higher number of CPUbackground threads-cores. However, this requires that applications make use of the available computation resources. 

The W3C responded to these new requirements with the web worker draft in 2009 providing the infrastructure for creating multi-threaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker API that allows running scripts in background threads. Each thread has its own memory area since the JavaScript memory model is not defined for concurrent access. This requires that cloned values be passed between threads using messaging. However, the messaging based programming model does not fit well into existing applications and the gap between the models needs to be bridged by the programmer --- adding non-inherent complexity to the program. The web worker standard further requires that code running in background threads be located in designated files. This separates coherent logic --- making the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main thread and another for the code running in web workers. 

Unfortunately, implementing multi-threaded applications targeting different environments in JavaScript is non-trivial either since no uniform standard for creating background threads exists. The web worker standard, defined by the W3C consortium, is only implemented in browsers. NodeJS allows spawning subprocess using the child-process API~\cite{childProcess}. JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS} that enables multi-threaded JavaScript --- including shared memory and all problems shared state brings with it. Therefore, an application needs to be explicitly adopted to the standards provided by its supported environments.

I believe that the platform dependent standards together with the inherent complexity caused by the programming model gap are the main reasons for the low spread of multi-threaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform independent, type safe API and runtime system for creating multi-threaded applications in JavaScript. The API abstracts the messaging based programming model used by some of the underlining standards, allowing a seamless integration into existing code. The runtime system consists of two parts: A low-level API allowing to run single functions on a background thread and a reactive API inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive API is mainly designed with simplicity in mind covering the aspects of work partitioning and result joining while providing a well-known and familiar API that allows an easy transformation of existing code. The low-level API is designated for the cases where more flexibility is needed or when the reactive programming model does not fit well with the problem to solve. 

This work further presents a transpiler that hides some of the limitations caused by the programming model gaps applying for task functions since it is technically impossible to cover up all limitations at runtime. The transpiler rewrites the code to reduce the programming model gap to a minimum. It adds debugging support, allows a function to import functionalities from libraries, calling other functions or accessing read-only variables from the outer closure. However, the use of the transpiler remains optional. 


The first section of this paper describes the related work and compares it to the presented solution. The following \cref{sec:programming-model} describes the programming model of parallel tasks and is followed by the \cref{sec:runtime-system} that explains the functionality of the runtime system. The \cref{sec:transpiler} explains which programming model differences can be hidden by using the transpiler. The \cref{sec:evaluation} compares the presented runtime system with the existing work and is followed by the conclusion. 