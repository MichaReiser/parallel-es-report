\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. From an unpopular language used to add dynamic effects to web pages to one widely used with a strong and growing community. It emerged from a browser-only language to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. The new use cases come along with new requirements demanding for more computational resources that can no longer be provided by a single threaded environment without negative affecting the user experience. Only using a single thread becomes, even more, severe with the spreading use of mobile devices in the world-wide-web. The CPUs of nowadays mobile devices have  --- compared to desktop computers --- a low clock rate but a higher number of CPU-cores. However, this requires that applications make use of the available computation resources. 

The W3C responded to these new requirements with the web worker draft in 2009 providing the infrastructure for creating multi-threaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker API that allows running scripts in background threads. Each thread has its own memory area since the  memory model of JavaScript is not defined for concurrent access. The absence of a shared memory requires that cloned values be passed between threads using messaging. However, the messaging based programming model does not fit well into existing applications and the gap between the models needs to be bridged by the programmer --- adding non-inherent complexity to the program. Furthermore, code running in background threads must be in designated files. This division of the code separates coherent logic --- making the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main thread and another for the code running in web workers. 

Unfortunately, implementing multi-threaded applications targeting different environments in JavaScript is non-trivial either since no uniform standard for creating background threads exists. The web worker standard, defined by the W3C consortium, is only implemented in browsers. NodeJS allows spawning subprocess using the child-process API~\cite{childProcess}. JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS} that enables multi-threaded JavaScript --- including shared memory and all problems shared state brings with it. This jungle of standards requires the specific adoption of applications to the standards provided by the used runtime environments.

The author believes that the platform dependent standards together with the inherent complexity caused by the programming model gap are the main reasons for the low spread of multi-threaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform independent, type safe API and runtime system for creating multi-threaded applications in JavaScript. The API abstracts the messaging based programming model used by some of the underlining standards, allowing a seamless integration into existing code. The runtime system consists of two parts: A low-level API allowing to run single functions on a background thread and a reactive API inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive API is mainly designed with simplicity in mind covering the aspects of work partitioning and result joining while providing a well-known and familiar API that allows an easy transformation of existing code. The low-level API provides more flexibility for the cases where the reactive programming model does not fit well with the problem to solve.

This work further presents a transpiler that hides some of the limitations caused by the programming model gaps applying for task functions since it is technically impossible to cover up all limitations at runtime. The transpiler rewrites the code to reduce the programming model gap to a minimum. It adds debugging support, allows a function to import functionalities from libraries, calling other functions or accessing read-only variables from the outer closure. However, the use of the transpiler remains optional. 


The first section of this paper describes the related work and compares it to the presented solution. The following section describes the programming model of parallel tasks and is followed by the \cref{sec:runtime-system} that explains the functionality of the runtime system. \Cref{sec:transpiler} describes the functioning of the transpiler that hides some of the programming model differences. The \cref{sec:evaluation} compares the presented runtime system with the existing work and is followed by the conclusion. 