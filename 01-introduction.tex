\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. It emerged from a browser-only to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. This shift comes along with more sophisticated requirements demanding for more computational resources that can no longer be provided by a single-threaded runtime system without negatively affecting the user experience. Moreover, the need for multithreaded runtime systems and applications has intensified in recent years because of the stagnating CPU clock rates and the spreading use of mobile devices with low clocked, multicore CPUs.

The W3C responded to these new demands with the web worker draft in 2009, laying the foundation for creating multithreaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker API that allows a script to run in a background thread without interfering with the user interface. The communication between threads is messaging-based, and each thread has its distinct memory area. However, the messaging-based programming model does not fit well into existing applications and results in a clear seam between existing code and code running in background threads. Moreover, code running in background threads has to be located in designated files. This unnatural division of the code separates coherent logic and makes the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main thread and another for the code running in background threads. 

Unfortunately, implementing multithreaded applications targeting different runtime environments in JavaScript is non-trivial since no uniform standard for creating background threads exists. The web worker standard, defined by the W3C consortium, is only implemented in browsers, NodeJS provides the child-process API~\cite{childProcess}, and JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS}, a JVM-based multithreaded runtime environment. This jungle of standards requires the explicit adoption of applications to the standards provided by the used runtime environments.

The platform-dependent standards together with the inherent complexity caused by the programming model gap are most likely the main reasons for the low spread of multithreaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform-independent type-safe API and runtime system for creating multithreaded applications in JavaScript. The API consists of two parts: Firstly, a low-level API allowing to run single functions on a background thread and secondly, a reactive API inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive API is designed to achieve simplicity in use by covering the aspects of work partitioning and result joining while providing a well-known and familiar API allowing an easy transformation of existing code. The low-level API provides more flexibility for the cases where the reactive programming model does not fit well with the problem to solve. The work further presents a transpiler that reduces the programming model gap to a minimum by rewriting the program code before execution allowing a seamless integration into existing code.  

The remainder of this paper is structured as follow: \Cref{sec:related-work} describes the related work and compares it with Parallel.es. \Cref{sec:programming-model} defines the programming model of background tasks. The execution of a background task and the design of the runtime system is described in \cref{sec:runtime-system}. \Cref{sec:transpiler} explains the functioning of the transpiler. The related work and the presented runtime system are evaluated in \cref{sec:evaluation} that is followed by the conclusion. 