\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. From an unpopular language used to add dynamic effects to web pages to one widely used with a strong and growing community. It emerged from a browser-only language to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. The new use cases come along with new requirements demanding for more computational resources that can no longer be provided by a single-threaded runtime system without negative affecting the user experience. Only using a single thread becomes, even more, severe with the spreading use of mobile devices in the world-wide-web. The CPUs of nowadays mobile devices have  --- compared to desktop computers --- a low clock rate but a higher number of CPU-cores. These circumstances require that applications make use of the available computation resources. 

The W3C responded to these new requirements with the web worker draft in 2009 providing the infrastructure for creating multithreaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker API allowing scripts to run in background threads instead of the main thread where it would interfere with the user interface. Each thread has its own memory area since the  memory model of JavaScript is not defined for concurrent access. The absence of a shared memory requires that cloned values be passed between threads using messaging. However, the messaging-based programming model does not fit well into existing applications and the gap between the models needs to be bridged by the programmer --- adding non-inherent complexity to the program. Moreover, code running in background threads must be located in designated files. This division of the code separates coherent logic and makes the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main thread and another for the code running in web workers. 

Unfortunately, implementing multithreaded applications targeting different runtime environments in JavaScript is non-trivial either since no uniform standard for creating background threads exists. The web worker standard, defined by the W3C consortium, is only implemented in browsers. NodeJS allows spawning subprocess using the child-process API~\cite{childProcess}. JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS} that enables multithreaded JavaScript --- including shared memory and all problems shared state brings with it. This jungle of standards requires the specific adoption of applications to the standards provided by the used runtime environments.

The author believes that the platform-dependent standards together with the inherent complexity caused by the programming model gap are the main reasons for the low spread of multithreaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform-independent type-safe API and runtime system for creating multithreaded applications in JavaScript. The programming model of the presented work abstracts the messaging-based programming model used by some underlying standards and therefore, allows a seamless integration between code running in background threads into existing code. This abstraction is achieved by the combination of a transpilation step rewriting the program code before execution and by the API of the runtime system. The transpiler exposes referenced variables from the main thread in the background thread and as well referenced functions. The API of the runtime system consists of two parts: Firstly, a low-level API allowing to run single functions on a background thread, and secondly a reactive API inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive API is mainly designed with simplicity in mind covering the aspects of work partitioning and result joining while providing a well-known and familiar API that allows an easy transformation of existing code. The low-level API provides more flexibility for the cases where the reactive programming model does not fit well with the problem to solve.


The first section describes the related work and compares it with Parallel.es. The remainder of this paper is structured as follow: \Cref{sec:programming-model} defines the programming model of parallel tasks. \Cref{sec:runtime-system} explains the design of the runtime system. \Cref{sec:transpiler} explains the functioning of the transpiler that rewrites the program code to allow task functions reference symbols from thier outer scope. The \cref{sec:evaluation} compares the presented runtime system with the related work and is followed by the conclusion. 