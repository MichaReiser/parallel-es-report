\section{Introduction}\label{sec:introduction}
The role of JavaScript drastically changed in recent years. It emerged from a browser-only to a general-purpose language used to write web-, desktop-, mobile-, and server-applications. This shift comes along with more sophisticated requirements demanding for more computational resources that can no longer be provided by a single-threaded runtime system without negatively affecting the user experience. The need for multithreaded applications has intensified in recent years because of the stagnating CPU clock rates and the spreading use of mobile devices with low clocked, multicore CPUs.

The W3C responded to these new demands with the web worker draft in 2009, providing the infrastructure for creating multithreaded applications~\cite{w3cWebWorker} in the browser. The draft defines the web worker API that allows a script to run in a background thread without interfering with the user interface. The web worker standard specifies a messaging-based programming model in which each thread has its distinct memory area. Message-passing is used since the memory model of JavaScript is not defined for concurrent access. However, the messaging-based programming model does not fit well into existing applications and the gap between the models needs to be bridged by the programmer --- adding non-inherent complexity to the program. Moreover, code running in background threads must be located in designated files. This unnatural division of the code separates coherent logic and makes the code less understandable. It also increases the complexity of the build process since two artifacts have to be created, one for the logic residing in the main thread and another for the code running in background threads. 

Unfortunately, implementing multithreaded applications targeting different runtime environments in JavaScript is non-trivial since no uniform standard for creating background threads exists: The web worker standard, defined by the W3C consortium, is only implemented in browsers. NodeJS allows spawning subprocess using the child-process API~\cite{childProcess}. JavaScript applications running on the JVM can use RingoJS~\cite{RingoJS} that enables multithreaded JavaScript --- including shared memory and all problems a shared state brings with it. This jungle of standards requires the explicit adoption of applications to the standards provided by the used runtime environments.

The platform-dependent standards together with the inherent complexity caused by the programming model gap are most likely the main reasons for the low spread of multithreaded applications in JavaScript. This paper presents \textit{Parallel.es}, a platform-independent type-safe API and runtime system for creating multithreaded applications in JavaScript. The programming model of the presented work abstracts the messaging-based programming model used by some underlying standards and therefore allows a seamless integration of code running in background threads into existing code. This abstraction is achieved by the combination of a transpilation step rewriting the program code before execution and by the design of the runtime system's API. The transpiler rewrites references from code running in background threads to variables and functions defined in the main thread and makes them available in the background thread. The API of the runtime system consists of two parts: Firstly, a low-level API allowing to run single functions on a background thread and secondly, a reactive API inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries. The reactive API is designed to achieve simplicity in use by covering the aspects of work partitioning and result joining while providing a well-known and familiar API that allows an effortless transformation of existing code. The low-level API provides more flexibility for the cases where the reactive programming model does not fit well with the problem to solve.

The remainder of this paper is structured as follow: The \cref{sec:related-work} describes the related work and compares it with Parallel.es. \Cref{sec:programming-model} defines the programming model of background tasks. \Cref{sec:runtime-system} describes the design of the runtime system. \Cref{sec:transpiler} explains the functioning of the transpiler that rewrites the program code to allow task functions reference symbols from their outer scope. \Cref{sec:evaluation} compares the presented runtime system with the related work and is followed by the conclusion. 