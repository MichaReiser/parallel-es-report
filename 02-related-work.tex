\section{Related Work}\label{sec:related-work}
There exists various open source projects addressing similar or equal goals. This section describes the differences of the presented work to the already existing ones. 

\subsection{Parallel.js}
Parallel.js~\cite{SavitzkyMayr2016} has been initiated in 2013 and is the oldest of the evaluated libraries. The main goal is to provide a simple api for multiprocessing in JavaScript. It provides an uniform api for the browser and NodeJS --- Web Workers are used in the Browser, child process~\cite{childProcess} on NodeJS. Parallel.js provides a low level api for running a function in a background thread and a reactive api providing an automatic task scheduling for the provided data. 


The latest published version on npm\footnote{NPM is a JavaScript Package Manager. The latest published version to date of Parallel.js is 0.2.1.} spawns a separate worker for every element in the input array exhausting the thread limits of the browser resulting in a crashed tab. The latest version on GitHub has adjusted the behavior to only spawn as many workers as max concurrency supported by the hardware. Therefore, when Parallel.js is referenced, the latest version\footnote{Commit 2e4b36bf16e330abaaff213e772fcf4074fd866b} from GitHub is meant.

This work differs from ParallelJS in the fact that a thread pool is used that reuses already created background-threads and performs queuing if needed. Parallel.js kind of has a thread pool approach but only on a per-operation (e.g. map or filter) basis. The second important difference is that Parallel.js requires that all operations are started from the ui-thread. This has the effect that if operations are chained, e.g. reducing a filtered array, than the filtered array is first returned to the ui-thread from where new workers are created to reduce the result. This results in unneeded --- and potentially very expensive --- copying of intermediate results from and to workers.

\subsection{Threads.js}
Thread.js~\cite{Wermke2016} aims to be a powerful but simple to use multi-threading library for NodeJS and the browser as well. Like Parallel.js, child processes are used in NodeJS and Web Workers in the browser.

The main difference of Threads.js is that it is messaging based. It therefore fits better in the underlining model provided by Web Workers and child processes by only providing a very tiny abstraction layer. However, it requires far more work if thread pools are used and if joining of the end result is desired as much of the work is left to the programer. However, Threads.js has support for transferables~\cite[Section 2.7.4]{w3cHtml5} that allows moving of typed arrays between background threads and ui-threads without the need for copying. 


\subsection{Hamsters.js}
Hamsters.js~\cite{hamstersjs} is the library with the highest attention measured by the number of GitHub stars. It provides a low level api for running functions in a background thread. The background threads are managed in a global thread pool. In addition various helper functionalities like like array sorting, aggregating or caching are provided. The library has support for Transferable objects and claims to support scheduling threads from a background-thread. The main differences to Hamsters.js is that the proposed api is type safe and provides a higher level api that simplifies parallelization. 