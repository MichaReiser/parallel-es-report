\section{Related Work}\label{sec:related-work}
There exists various open source projects addressing similar or equal goals. This section describes the differences of the presented work to the already existing ones. One main difference of the the presented system to the related work is that it offers the same debugging functionalities as developers are used to when working with synchronous code.

\subsection{Hamsters.js}
Hamsters.js~\cite{hamstersjs} is the library with the highest attention measured by the number of GitHub stars. It provides a low level api for running functions in a background thread. The background threads are managed in a global thread pool. In addition, various helper functionalities like array sorting, aggregating or caching are provided. The library has support for transferable objects and claims to support scheduling threads from a background-thread. 

The main differences to Hamsters.js is that the proposed work offers a higher level api that simplifies parallelization. 

\subsection{Parallel.js}
Parallel.js~\cite{SavitzkyMayr2016} has been initiated in 2013 and is the oldest of the evaluated libraries. Its main goal is to provide a simple api for multiprocessing in JavaScript. It provides an uniform api for the browser and NodeJS --- web workers are used in the browser, child processes~\cite{childProcess} on NodeJS. Parallel.js provides a low level api for running a function in a background thread and a reactive api providing an automatic task scheduling for the provided data. 

This work differs from Parallel.js in the fact that a thread pool is used that reuses already created background-threads and performs queuing if needed. Parallel.js has kind of a thread pool approach but only on a per-operation (e.g. map or filter) basis. The second important difference is that Parallel.js awaits the sub results of the proceeding operation before continuing with the next operation if multiple operations are chained together, e.g. the reduce step that sums up the values of a filtered array awaits until all background-threads have completed filtering the array before starting with summing up the values. Furthermore, the sub results are always transmitted back to the main-thread before starting the next operation on new background-threads. This results in unneeded --- and potentially very expensive --- copying of intermediate results from and to background-threads.


The latest published version on npm\footnote{NPM is a JavaScript Package Manager. The latest published version to date of Parallel.js is 0.2.1.} spawns a separate worker for every element in the input array exhausting the thread limits of the browser. The latest version on GitHub has adjusted this behavior to only spawn as many workers as logical processors are available by the hardware. Therefore, when Parallel.js is referenced, the latest version\footnote{Commit 2e4b36bf16e330abaaff213e772fcf4074fd866b} from GitHub is meant.

\subsection{Threads.js}
Thread.js~\cite{Wermke2016} aims to be a powerful but simple to use multi-threading library for NodeJS and the browser as well. Like Parallel.js, child processes are used in NodeJS and web workers in the browser.

The main difference of Threads.js is that it is messaging based. It therefore fits better to the programing model used by web workers and child processes. However, this requires that the programer bridges the gap between the programing model used inside the application and the messaging based programing model of Threads.js