\section{Programming Model}\label{sec:programming-model}
The programming model of Parallel.es motivates the programmer to perform time-intensive computations asynchronously and potentially concurrently in background tasks. 

\subsection{Background Task}
A \textit{background task} --- further referred to as task --- represents a single asynchronous operation executed on a background thread and is implemented by a JavaScript function. \Cref{fig:fibonacci-implementation} shows an example that computes the Fibonacci number for the value 100 in a task and logs the result to the console. The task is started using the \javascriptinline/run/ method by passing the function to execute together with the arguments for the function call (line \ref{code:parallel-run}). The returned object implements the promise interface~\cite[Section 18.3.18]{ecmaScript2015} allowing to register a \javascriptinline/then/ callback that is invoked with the result if the computation was successful and an error handler (\javascriptinline/catch/) that is triggered otherwise. These callbacks are executed on the main thread and allow retrieval of the result or error. 


\begin{listing}
	\begin{javascriptcode*}{highlightlines={9-11}}
function fib(num) {
	if (num <= 2) {
    	return 1;
	}

	return fib(num - 1) + fib(num - 2);
}
        
parallel.run(fib, 100) |$\label{code:parallel-run}$|
	.catch(error => console.error(error))
	.then(result => console.log(result));	
	\end{javascriptcode*}

	\caption{Fibonacci Implementation}
	\label{fig:fibonacci-implementation}
\end{listing}

The sound task-functions are a subset of all JavaScript functions. Task-functions can refer to arbitrary, non-shared variables declared inside of the task-function. However, references to symbols from the outer scope are restricted: References to non-read-only variables are prohibited\footnote{The special identifiers \javascriptinline/this/ and \javascriptinline/super/ are treated equally to other identifiers referring to variables from the outer scope, and their usage inside of a task function is therefore prohibited. This restriction also implies that an arrow function used as task function is semantically equal to a function expression.} and as well references to functions that are not resolvable by using static scoping, e.g. functions passed as arguments in a function call. The referenced variables are passed by-value by creating a structured clone~\cite[Section 2.9.4]{WHATWG2016}. The structured cloning requires that the passed variables be serializable, e.g. Functions, DOM-Elements, and Errors are not cloneable. The result returned by the task is also passed by-value-semantic requiring to be structured cloneable as well. References to non-read-only variables are detected and prevented by the transpiler. However, the transpiler does not prevent references to undeclared variables since these variables might be globally defined by the runtime environment and therefore, result in runtime errors\footnote{To identify references to undeclared variables either a typed language can be used or a linter like ESLint~\cite{eslint} that is designed therefore.}.

The global context in which a task function is defined differs from the global context of the background threads executing the task function. Changes made to the global context of one thread are not visible to the other threads since each thread has its own global context. Therefore, the global context cannot be used to store shared state.  Furthermore, the APIs accessible in background threads may vary from the one offered in the main thread, e.g. the DOM API is not accessible to web workers.  These are no significant limitations for task functions since they perform in general compute intensive, but side effect free, operations only depending on local data.

Parallel tasks are isolated from one another since tasks share no variables and every thread executes one task at a time. However, the tasks executed in a specific background thread share the same global state. It is, therefore, possible that a task affects another task if they access and modify the same global state. Modification to the global state are not prevented but are strongly discouraged as changes are only thread-local --- and therefore, not replicated between threads --- and may introduce memory leaks. 

\subsection{Reactive API}
The runtime system further offers a reactive API~\cite{Meijer2012}. It is inspired by the commonly used underscore~\cite{underscorejs} and lodash~\cite{lodash} libraries and motivates the programmer to define the computations as operations on data-streams. The runtime system takes care of splitting the work into several sub-tasks and aggregating the sub-results into the end-result. The created tasks perform all operations on a subset of the input values and are potentially executed concurrently. The goal of this API is to provide a well-known and understood API that uses the available computation resources without any further actions needed by the programmer. Adopting a well-known and commonly used API facilitates a fast learning curve and simplifies parallelizing existing synchronous code. The reactive API uses the infrastructure provided by the low-level API. Therefore, the same programming model applies.


 An implementation of the Mandelbrot computation using the reactive API of Parallel.es is shown in \cref{code:mandelbrot-parallel.es}. The parallel implementation differs only slightly from the synchronous, lodash~\cite{lodash} based implementation shown in \cref{fig:mandelbrot-sync}. This alikeness of the APIs facilitates a fast learning curve and simplifies transitioning existing code. The \javascriptinline/range/ method (line \ref{code:parallel-es-definition-start}) defines the data-stream to process. It creates a data-stream containing the values from 0 up to the image height. The input stream is transformed by mapping (\javascriptinline/map/ on line \ref{code:parallel-es-map}) each element from the input stream to an output element that is computed by the \javascriptinline/computeMandelbrotLine/ function (line \ref{code:parallel-es-operation}). The \javascriptinline/computeMandelbrotLine/ function --- that is executed in a background thread --- has access to the current array element and the read-only variables from the outer scope. It can further make use of the \javascriptinline/computePixel/ (line \ref{code:mandelbrot-compute-pixel}) function defined in the outer scope or functions imported from other modules. The computation is started using the \javascriptinline/then/ method (line \ref{code:parallel-es-start}) that registers a callback. The \javascriptinline/then/ callback is executed in the main thread and is invoked with a single array containing the joined lines of the Mandelbrot if the computation succeeds. An optional error callback can be defined as well that is invoked incase the execution failed. The API further allows to retrieve sub-results by registering a callback that is invoked whenever the computation of a task has completed by using \javascriptinline/subscribe/ (line \ref{code:parallel-es-subscribe}). The \javascriptinline/subscribe/ callback is invoked in the task completion order and not sequentially. The sub-results can be used to already show the user the up to now computed result. 
 
\begin{listing}
	\begin{javascriptcode*}{highlightlines={9, 17-21}}
const imageWidth = 10000;
const imageHeight = 10000;

function computePixel(x, y) { |$\label{code:mandelbrot-compute-pixel}$|
	// ...
	return n;
}

function computeMandelbrotLine(y) { |$\label{code:parallel-es-operation}$|
	const line = new Uint8ClampedArray(imageWidth * 4); |$\label{code:mandelbrot-reference1-imageWidth}$|
	for (let x = 0; x < imageWidth; ++x) {
		line[x * 4] = computePixel(x, y);
	}
	return line;
}

parallel
	.range(imageHeight) |$\label{code:parallel-es-definition-start}$|
	.map(computeMandelbrotLine)	 |$\label{code:parallel-es-map}$|
	.subscribe(((subResult, index, batchSize)) => ...) |$\label{code:parallel-es-subscribe}$|
	.then(result => console.log(result)); |$\label{code:parallel-es-start}$|
	\end{javascriptcode*}
	
	\caption{Mandelbrot Implementation in Parallel.es}
	\label{code:mandelbrot-parallel.es}
\end{listing}


\begin{listing}
	
	\begin{javascriptcode}
const imageWidth = 10000;
const imageHeight = 10000;

function computePixel(x, y) {
	// ...
	return n;
}

function computeMandelbrotLine(y) {
	const line = new Uint8ClampedArray(imageWidth * 4);
	for (let x = 0; x < imageWidth; ++x) {
		line[x * 4] = computePixel(x, y);
	}
	return line;
}

const result = _.chain()
	.range(imageHeight)
	.map(computeMandelbrotLine)
	.value();
	
console.log(result);
\end{javascriptcode}
\caption{Synchronous Mandelbrot Implementation using Lodash~\cite{lodash}}
\label{fig:mandelbrot-sync}
\end{listing}