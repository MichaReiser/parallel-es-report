\section{Programing Model}\label{sec:programing-model}
The programing model of Parallel.es motivates the programer to perform time intensive computations asynchronous, and potentially concurrently, in background-tasks. 

\subsection{Background Task}
A \textit{background task} --- further referred to as task --- represents a single asynchronous operation executed on a background-thread and is implemented by a JavaScript function. \Cref{fig:fibonacci-implementation} shows an example that computes the fibonacci number for the value 100 in a task and logs the result to the console. The task is started using the \javascriptinline/run/ method by passing the function to execute together with the arguments for the function call (line \ref{code:parallel-run}). The returned object implements the promise interface~\cite[Section 18.3.18]{ecmaScript2015} allowing to register a \javascriptinline/then/ callback that is invoked with the result if the computation was successful and an error handler (\javascriptinline/catch/) that is triggered otherwise. The callbacks are executed on the main-thread and allow retrieval of the result. 


\begin{figure}
	\begin{javascriptcode}
function fib(num) {
	if (num <= 2) {
    	return 1;
	}

	return fib(num - 1) + fib(num - 2);
}
        
parallel.run(fib, 100) |$\label{code:parallel-run}$|
	.catch(error => console.error(error))
	.then(result => console.log(result));	
	\end{javascriptcode}

	\caption{Fibonacci Implementation}
	\label{fig:fibonacci-implementation}
\end{figure}

The valid task-functions are only a subset of all JavaScript functions since not all JavaScript features are allowed to be used. This is rooted in the fact that neither web workers nor child processes have a shared memory\footnote{This might change with the SharedMemory~\cite{Ecma2016} standard that is currently a draft in stage 2.} that can be used to store data accessed by different threads. It is therefore disallowed that a task-function references any variables or functions --- including imports from external files --- from the outer scope\footnote{The special identifiers \javascriptinline/this/ and \javascriptinline/super/ are treaded equally to other identifiers referring to variables from the outer scope and their usage inside of a task-function is therefore prohibited. This also implies that an arrow function used as task-function is semantically equal to a function expression.}. Data needed by a task function needs to be explicitly passed when the task is started and is serialized using the structured clone algorithm~\cite[Section 2.9.4]{WHATWG2016}. This enforces a pass-by-value semantic and requires that the passed data is serializable according to the structured clone standard, e.g. Functions, DOM-Elements and errors are not cloneable. The same applies for the result returned by the task. 

The global context of a task differs from the global context the function is defined it. Changes made in the main-thread or inside of a single task are not reflected across the threads. Furthermore, the api exposed by the environment may differ, e.g. the DOM api is not exposed inside of web workers. This does not add strong limitations to task-functions since task functions mainly are used to perform compute intensive operations that depend on local data only.

Parallel tasks are isolated from one another since each tasks operates on its own copy of the variables and every thread only executes on task at the time. However, the global state of a thread is shared among all tasks executed on this thread instances. Tasks can access and modify the global state. This is strongly discouraged as changes are only thread local --- and therefore not replicated between threads --- and may introduce memory leaks. 

\subsection{Reactive API}
The proposed work further offers a reactive api that provides automatic work partitioning and result joining. The api is inspired by the commonly used underscore and lodash libraries. The goal of this api is to provide a well known and understood api that uses the available computation resources without any further actions by the programer. This simplifies it for the programmer to transform synchronous implementations into parallelized ones. The api is based on top of the low level api and therefore the same restrictions apply. 

The api motivates the programer to define the computations as operations on a data flow. The defined operations on the data flow are chained together and are executed concurrently as multiple tasks. An implementation of the Mandelbrot computation using Paralle.es is shown in \cref{code:mandelbrot-parallel.es}. The implementation differs only slightly from the synchronous implementation shown in \cref{fig:mandelbrot-sync}. The task is defined from line \ref{code:parallel-es-definition-start} to \ref{code:parallel-es-definition-end} using the descriptive api. The \javascriptinline/range/ method defines the input as a range from 0 up to the image height. The object passed to \javascriptinline/inEnvironment/ is available to the function in the background task through an additional function parameter. The operation to apply to every element from the data stream is \javascriptinline/map/ with the passed mapping function \javascriptinline/computeMandelbrotLine/. The computation is started using the \javascriptinline/then/ operation (line \ref{code:parallel-es-start}) that registers a callback to invoke in case the computation succeeds --- an optional error callback can be defined as well. The then callback is executed in the ui-thread. The \javascriptinline/computeMandelbrotLine/ function (line \ref{code:parallel-es-operation}) --- that is executed on the background-thread --- has access to the current array element and as well to the \javascriptinline/environment/ object that was passed in the \javascriptinline/inEnvironment/ call. No additional build step is required.


\begin{figure}
	\begin{javascriptcode}
function computeMandelbrotLine(y, environment) { |$\label{code:parallel-es-operation}$|
	const arrazSize = environment.imageWidth * 4;
	const line = new Uint8ClampedArray(arraySize);
	// compute...
	return line;
}

parallel      |$\label{code:parallel-es-definition-start}$|
	.range(options.imageHeight)
	.inEnvironment(options)
	.map(computeMandelbrotLine) |$\label{code:parallel-es-definition-end}$|
	.then(result => console.log(result); |$\label{code:parallel-es-start}$|
	\end{javascriptcode}
	
	\caption{Mandelbrot Implementation in parallel.es}
	\label{code:mandelbrot-parallel.es}
\end{figure}

\begin{figure}
	
	\begin{javascriptcode}
function computeMandelbrotLine(y, options) {
	const arraySize = options.imageWidth * 4;
	const line = new Uint8ClampedArray(arraySize);
	// compute...
	return line;
}

const range = _.range(options.imageHeight);
const result = range.map(
	y => computeMandelbrotLine(y, options)
);
console.log(result);
\end{javascriptcode}
\caption{Synchronous Mandelbrot Implementation}
\label{fig:mandelbrot-sync}
\end{figure}

%\subsection{Task Implementation}
%A task is implemented by a JavaScript function. The 
%
%% The following is how it is implemented but not what the programing model defines
%
%This is inherited from the Web Worker programing model where each Worker uses its own memory and data exchange requires messaging\footnote{This might change with the SharedMemory~\cite{Ecma2016} standard that is currently a draft in stage 2.} resulting in various restrictions applying to the functions implementing a task. Some of these restrictions can be hidden by using the proposed code transpilation step described in TODO\todo{add ref}.
%
%It is prohibited for a task function to access any variables --- including functions and imports --- from its closure. This is rooted in the fact that the variables from the closure resist in the memory of the ui-thread and not in the thread executing the task. However, required data can be passed as function arguments to the task in question. Structured clone~\cite[Section 2.9.4]{WHATWG2016} is used to transfer data between threads.


