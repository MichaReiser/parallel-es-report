\section{Transpiler}\label{sec:transpiler}
The absence of a shared memory accessible by all threads\footnote{This might change with the SharedMemory~\cite{Ecma2016} standard that is currently a draft in stage 2.} that allows to store shared variables requires an explicit passing of variables referenced by a task function to the background thread executing the function. The transpiler covers this needed step by rewriting the program code. The use of the transpiler is optional if task functions are not referencing symbols from their outer scope.


The transpiler is based on top of webpack\footnote{A JavaScript module bundler.}~\cite{webpack} and Babel\footnote{A framework for Transforming JavaScript code.}~\cite{babel}. It extracts the task functions from the code, adds it to the file loaded by the slaves, adds required import statements and pre-registers the task function in the slave's function cache. 

The transpiler rewrites the program code and makes variables referenced from the outer scope and referenced functions available to the task function. In case of the Mandelbrot implementation shown in \cref{code:mandelbrot-parallel.es}, the variable \javascriptinline/imageWidth/ (line \ref{code:mandelbrot-reference1-imageWidth}) and the function \javascriptinline/computePixel/ (line \ref{code:mandelbrot-compute-pixel}) are made available to the task function. \Cref{fig:mandelbrot-transpiled} shows the transpiled Mandelbrot implementation. The transpiler creates the new function \javascriptinline/_environmentExtractor/ (line \ref{code:mandelbrot-environment-extractor}) that returns an object containing the values of all referenced variables and inserts it above the definition of the task function. This function is used to extract the value of the referenced variable \javascriptinline/imageWidth/ in the master thread. The object returned by the \javascriptinline/_environmentExtractor/ function is made available to the task function by setting it as environment using the \javascriptinline/inEnvironment/ method (line \ref{code:mandelbrot-environment-call}). The object passed to \javascriptinline/inEnvironment/ is passed as last argument to the task function. The transpiler further replaces the task definition by a unique function-id (lines \ref{code:mandelbrot-function-id-start}-\ref{code:mandelbrot-function-id-end}) that the slave uses to resolve the function from the function cache\footnote{The transpiler does not remove the task function from the code run in the main thread since it might be used elsewhere. Webpack 2 can eliminate the function using tree shaking if it is not used elsewhere in the main thread.}. 

\begin{listing}
	\begin{javascriptcode*}{highlightlines={9-13, 26-29}}
const imageWidth = 10000;
const imageHeight = 10000;

function computePixel(x, y) {
	// ...
	return n;
}

function _environmentExtractor() { |$\label{code:mandelbrot-environment-extractor}$|
	return {
		imageWidth: imageWidth
	};
}

function computeMandelbrotLine(y) {
	const line = new Uint8ClampedArray(imageWidth * 4);
	for (let x = 0; x < imageWidth; ++x) {
		line[x * 4] = computePixel(x, y);
	}
	return line;
}

parallel
	.range(imageHeight)
	.inEnvironment(_environmentExtractor()) |$\label{code:mandelbrot-environment-call}$|
	.map({ |$\label{code:mandelbrot-function-id-start}$|
		identifier: "static:_entrycomputeMandelbrotLine",
		_______isFunctionId: true
	}) |$\label{code:mandelbrot-function-id-end}$|
	.then(result => console.log(result));
\end{javascriptcode*}
\caption{Transpiled Mandelbrot Implementation}
\label{fig:mandelbrot-transpiled}
\end{listing}


\Cref{fig:transpiled-mandelbrot-slave} shows the code inserted by the transpiler into the script run by the slaves. The transpiler injects the code of the task function (lines \ref{code:slave-task function-start}-\ref{code:slave-task function-end}) and the referenced \javascriptinline/computePixel/ function (lines \ref{code:slave-compute-pixel-start}-\ref{code:slave-compute-pixel-end})\footnote{The transpiler wraps the functions of each module in the code run on the slaves with an immediately invoked function expression to isolate the functions of one module from the others and avoid naming clashes.}. Further, an \textit{entry}-function (lines \ref{code:slave-entry-function-start}-\ref{code:slave-entry-function-end}) is generated that initializes the \javascriptinline/imageWidth/ variable (line \ref{code:slave-image-width}) with the value stored in the environment --- that contains the values of the variables from the main thread --- and calls the actual task function. The entry function is registered in the function cache (lines \ref{code:slave-register-function-start}-\ref{code:slave-register-function-end}) using the same function id as utilized in the master thread. This pre-registration allows the slave to retrieve the function immediately from the function cache without the need to request the function definition from the master --- that requires (de-) serialization of the function.

\begin{listing}
\begin{javascriptcode*}{highlightlines={1, 3, 8, 16, 26-31}}
var imageWidth; |$\label{code:slave-image-width}$|

function computePixel(x, y) { |$\label{code:slave-compute-pixel-start}$|
	// ...
	return n;
}|$\label{code:slave-compute-pixel-end}$|

function computeMandelbrotLine(y) { |$\label{code:slave-task function-start}$|
	var line = new Uint8ClampedArray(imageWidth * 4);
	for (var x = 0; x < imageWidth; ++x) {
		line[x * 4] = computePixel(x, y);
	}
	return line;
}|$\label{code:slave-task function-end}$|
 
function _entrycomputeMandelbrotLine() { |$\label{code:slave-entry-function-start}$|
	try {
		var _environment = arguments[arguments.length - 1];
		imageWidth = _environment.imageWidth;
		return computeMandelbrotLine.apply(this, arguments);
	} finally {
		imageWidth = undefined;
	}
} |$\label{code:slave-entry-function-end}$|

slaveFunctionLookupTable.registerStaticFunction({|$\label{code:slave-register-function-start}$|
		identifier: 'static:_entrycomputeMandelbrotLine',
		_______isFunctionId: true
	}, _entrycomputeMandelbrotLine); |$\label{code:slave-register-function-end}$|
\end{javascriptcode*}
\caption{Generated Slave-Code for the Transpiled Mandelbrot Implementation}
\label{fig:transpiled-mandelbrot-slave}
\end{listing}

The transpiler further generates source maps that point back to the original location of the extracted task function and as well, transitive referenced functions. The source maps enable a true debugging experience that allows setting breakpoints inside of the browser developer tools\footnote{This is currently only supported by the developer tools of Google Chrome and Microsoft Edge.}. Without these source maps, breaking inside of a task function is only possible by using the inflexible \javascriptinline/debugger/ statement. The source maps further allow the browser to translate error messages back to the original code. Helping to identify the cause of an error from production. The source map support is a distinct feature not offered by any of the related work.

\subsection{Implementation Restrictions}
The current implementation of the transpiler only supports the reactive API even though no technical reason therefore exists. By design, the transpiler prohibits references to non-constant variables --- a variable is assumed to be constant if the value is assigned in the declaration and is never changed afterward. This restriction prevents visibility issues since a programmer might assume that the runtime system reflects changes to variables across threads. 

The current implementation only uses static scoping to resolve imports and functions. Functions and imports where the resolution requires data flow analysis are therefore not supported, e.g. it is unsupported to call functions passed as function arguments. The transpiler only supports ES6 modules and imports for the same reason.
