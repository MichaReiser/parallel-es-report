\section{Conclusion}\label{sec:conclusion}
A typical JavaScript application runs only inside of the main thread and therefore, only sparsely uses the available computation resources of nowadays computers. However, with the increasing complexity of the applications running in JavaScript, the immersed rise of mobile and IoT devices with a relatively low CPU clock, and stagnating CPU frequencies, the adoption of applications to multicore architecture is indispensable. Even though, writing multithreaded JavaScript applications is non-trivial because the standards for creating background threads are platform-dependent and often enforce a messaging-based communication model that introduces non-inherent complexity to applications.

This paper presented a runtime environment independent, type-safe API and runtime system that provides a seamless integration of parallel tasks into existing applications. It addresses the different needs of programmers by providing two APIs, a low-level API that allows running a single function in a background thread and a reactive API allowing parallelizing data flow based operations with ease. 

The evaluation showed that most existing runtime systems perform similarly concerning execution time when applied to the given set of problems. Parallel.es is not always the fastest runtime-system, but never performs significantly slower than the others for any problem instance. However, the main advantage of the library over the related work is its API and integration into existing code.  The proposed API is close to APIs commonly used by programmers to write synchronous code facilitating fast learning and straightforward transitioning of existing code. Moreover, Parallel.es is to be preferred for projects using typed language like Flow or TypeScript since none of the related work offers a type-safe API. Combining the runtime system with the transpiler has further the benefit of a seamless integration of parallel tasks into existing code that cannot be achieved by any related work. Without the transpiler, the programmer is forced to structure the code in the way supported by the runtime system resulting in a clear break in the code style. The transpiler further generates source maps pointing back to the original code helping identifying errors from production and enable a pleasant debugging experience, a feature not offered by any related work.

However, the evaluation also showed that the proposed system does not fit well with recursive problems like Quicksort or Knight-Tour that require a system supporting recursive tasks. Adding support for recursive tasks is non-trivial and subject of further research. Nevertheless, the proposed work eases creating multithreaded applications enabling them to use the computation power provided by the underlying hardware and hopefully contributes to the growth of multithreaded applications written in JavaScript. 