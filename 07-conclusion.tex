\section{Conclusion}\label{sec:conclusion}
A typical JavaScript application runs only inside of the main thread and therefore, does not make use of all the available computation resources. However, with the increasing complexity of the problems implemented in JavaScript, the immersed rise of mobile and IoT devices in the world-wide with a relatively low CPU clock but multiple cores, and stagnating CPU frequencies, the adoption of applications to multicore architecture is more essential than ever. All the prominent JavaScript environments answered to this trend with an environment-specific standard for spawning background threads where most use a messaging-based communication model between threads. However, this jungle of standards and the programming model gap hardens writing application taking profit of the multicore hardware available. 

This paper presented Parallel.es, a runtime environment independent, type safe API and runtime system that aims to provide a seamless integration of parallel tasks into the existing programming model to address this need. It addresses the different needs of programmers by providing two APIs, a low-level API that allows running a single function in a background thread, but otherwise, does not offer any assistance and a reactive based API that allows parallelizing data flow based operations with ease. Furthermore, a  transpiler has been presented that hides most of the limitations rooted in the programming model gap by rewriting the relevant code and allowing an even \enquote{seam-lesser} co-existence of parallel tasks and synchronous code. 

The evaluation showed that most existing runtime systems perform similarly with respect to execution time when applied to the given set of problems. Parallel.ese is neither the fastest runtime-system nor does is it significantly slower than others in any problem instance. Besides performance, a key factor when choosing a library is its API and integration into existing code and tools. The evaluation showed that none of the related work offers a true type safe API as it is by Parallel.es. Therefore, using Parallel.es together with typed languages like Flow or TypeScript is clearly to be preferred over the other runtime systems. Besides type safety, the API has been evaluated, but clearly, states the opinion of the --- biased -- author. Hamsters.js API is the least trivial to use because all features are exposed by a single function, resulting in a very lengthy argument-list. The API of Threads.js is clean and simple in use but its programming model also uses messaging that hardens transitioning existing code and code reuse. The API offered by Parallel.js and Parallel.es are almost equivalent and allow easy parallelization of operations applied to data streams. A unique feature of Parallel.es achieved by using the transpilation is to offer same debugging functionality as developers are used to from synchronous code. 

