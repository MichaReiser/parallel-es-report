\section{Conclusion}\label{sec:conclusion}
A typical JavaScript application runs only inside of the main thread and therefore, only sparsely uses the available computation resources of nowadays computers. However, with the increasing complexity of the applications running in JavaScript, the immersed rise of mobile and IoT devices with a relatively low CPU clock, and stagnating CPU frequencies, the adoption of applications to multicore architecture is indispensable. Even though, writing multithreaded JavaScript applications is non-trivial because the standards for creating background threads are platform-dependent and often enforce a messaging-based communication model that introduces non-inherent complexity to applications.

This paper presented a platform independent, type-safe API and runtime system that provides a seamless integration of parallel tasks into existing applications. It addresses the different needs of programmers by providing two APIs, a low-level API that allows running a single function in a background thread and a reactive API allowing parallelizing data flow based operations with ease. 

The evaluation shows that most existing runtime systems perform similarly concerning execution time when applied to the given set of problems. Parallel.es is not always the fastest runtime-system, but never performs significantly slower than the others for any problem instance. However, the main advantage of the library over the related work is its API and seamless integration into existing code.  The proposed API is close to APIs widely used by the JavaScript community to write synchronous code facilitating fast learning and straightforward transitioning of existing code. Moreover, Parallel.es is to be preferred for projects using typed language like TypeScript~\cite{typescript} or Flow~\cite{flow} since none of the related work offers a type-safe API. The presented transpiler has further the benefit that task functions can reference read-only variables and functions from its outer scope without any additional doing of the programmer. On the contrary, the related work forces the programmer to structure the code in the way supported by the runtime system resulting in a clear break in the code style. The additional transpilation step has further the advantage that the generated source maps help identifying errors from production and enable a pleasant debugging experience, a feature not offered by any related work. Nevertheless, the use of the transpiler remains optional for those preferring to avoid an additional build step.

The evaluation also showed that the proposed system does not fit well with recursive problems like Quicksort or Knight-Tour that require a system supporting recursive tasks. Adding support for recursive tasks is non-trivial and subject of further research. Nevertheless, the proposed work eases creating multithreaded applications enabling them to use the computation power provided by the underlying hardware and is believed to contribute to the growth of multithreaded applications written in JavaScript. 